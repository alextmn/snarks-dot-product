/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <cassert>
#include <cstdio>

#include <libff/common/profiling.hpp>
#include <libff/common/utils.hpp>

#include <libsnark/common/default_types/r1cs_ppzksnark_pp.hpp>
#include "r1cs_constrain_cointainer.hpp"
#include "r1cs_inner_product.hpp"
#include "run_r1cs_ppzksnark.hpp"
/* Header for class HelloJNI */

#ifdef __cplusplus
extern "C" {
#endif

JNIEXPORT void JNICALL Java_com_td_snarks_curcuits_ZkDotProduct_generate(JNIEnv *env, jobject thisObj, jint vectorSize, jobject cb);
JNIEXPORT jbyteArray JNICALL Java_com_td_snarks_curcuits_ZkDotProduct_createProof(JNIEnv *env, jobject thisObj, jbyteArray pk, jlongArray a, jlongArray b);
JNIEXPORT jboolean JNICALL Java_com_td_snarks_curcuits_ZkDotProduct_verify(JNIEnv *env, jobject thisObj,jlong product, jbyteArray vk, jbyteArray proof);

#ifdef __cplusplus
}
#endif
using namespace libsnark;

int32_t isInitilized(0);
void inline ensureInitilized() {
    if (!isInitilized) {
        default_r1cs_ppzksnark_pp::init_public_params();
        isInitilized = 1;
    }
}

JNIEXPORT void JNICALL Java_com_td_snarks_curcuits_ZkDotProduct_generate(JNIEnv *env, jobject thisObj, jint vectorSize, jobject cbObj) {
    ensureInitilized();
    // create a circuit
    r1cs_constrain_cointainer<libff::Fr<default_r1cs_ppzksnark_pp> > container = 
        fill_with_constant(0, (int32_t) vectorSize );

    // geerate key pair
    std::tuple< std::string, std::string  > keyPair =  
            circuit_key_generation<default_r1cs_ppzksnark_pp>(container);

    jclass cls = env->FindClass("com/td/snarks/curcuits/KeyGenerationFunc");
    if (cls == 0 ) {
         printf("class com/td/snarks/curcuits/KeyGenerationFunc not found!\n");
         return;
    }
    jmethodID method = env->GetMethodID(cls, "onKeyPair", "([B[B)V");
    if (method == 0 ) {
        printf("method onKeyPair is not found!\n");
        return;
   
    }
   std::string pk, vk;
   pk = std::get<0>(keyPair), vk = std::get<1>(keyPair);
   jbyteArray pkArray = env->NewByteArray(pk.size());
   env->SetByteArrayRegion (pkArray, 0, pk.size(), reinterpret_cast<const jbyte*>(pk.c_str()));
   jbyteArray vkArray = env->NewByteArray(vk.size());
   env->SetByteArrayRegion(vkArray, 0, vk.size(), reinterpret_cast<const jbyte*>(vk.c_str()));
   env->CallObjectMethod(cbObj, method,pkArray,vkArray);
 }

 JNIEXPORT jbyteArray JNICALL Java_com_td_snarks_curcuits_ZkDotProduct_createProof(JNIEnv *env, jobject thisObj, jbyteArray pk, jlongArray a, jlongArray b) {

    ensureInitilized();

    unsigned char isCopy(JNI_FALSE);
    int32_t pkSize = env->GetArrayLength(pk);
    jbyte* pkBytes = env->GetByteArrayElements(pk, &isCopy);
    std::string proofKey(pkBytes,pkBytes + pkSize );
 
    jlong* al = env->GetLongArrayElements(a, &isCopy);
    jlong* bl = env->GetLongArrayElements(b, &isCopy);
    TupleVecT tupleVector;
    for (size_t i = 0; i < env->GetArrayLength(a); i++ ) {
        tupleVector.push_back(std::make_tuple(al[i], bl[i]));
    }

    r1cs_constrain_cointainer<libff::Fr<default_r1cs_ppzksnark_pp> > container = 
             circuit(tupleVector); 

    std::string proof;
    proof = create_proof<default_r1cs_ppzksnark_pp>(container ,proofKey);

    jbyteArray aProof = env->NewByteArray(proof.size());
    env->SetByteArrayRegion(aProof, 0, proof.size(), reinterpret_cast<const jbyte*>( proof.c_str() ));
    return  aProof;
}


JNIEXPORT jboolean JNICALL Java_com_td_snarks_curcuits_ZkDotProduct_verify(JNIEnv *env, 
        jobject thisObj,jlong product, jbyteArray vk, jbyteArray proof) {

    ensureInitilized();
    unsigned char isCopy(JNI_FALSE);
    jbyte* proofBytes = env->GetByteArrayElements(proof, &isCopy);
    std::string sProof(proofBytes, proofBytes + 
            env->GetArrayLength(proof));
    
    
    jbyte* vkBytes = env->GetByteArrayElements(vk, &isCopy);
    std::string sVk(vkBytes, vkBytes + 
            env->GetArrayLength(vk));
        
    return  verify_proof<default_r1cs_ppzksnark_pp>(sProof, sVk, product );
}
