/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <cassert>
#include <cstdio>

#include <libff/common/profiling.hpp>
#include <libff/common/utils.hpp>

#include <libsnark/common/default_types/r1cs_ppzksnark_pp.hpp>
#include "r1cs_constrain_cointainer.hpp"
#include "r1cs_inner_product.hpp"
#include "run_r1cs_ppzksnark.hpp"
/* Header for class HelloJNI */

#ifdef __cplusplus
extern "C" {
#endif

JNIEXPORT void JNICALL Java_HelloJNI_generate(JNIEnv *env, jobject thisObj, jint vectorSize, jobject cb);
JNIEXPORT jbyteArray JNICALL Java_HelloJNI_createProof(JNIEnv *env, jobject thisObj, jbyteArray pk, jlongArray a, jlongArray b);
JNIEXPORT jboolean JNICALL Java_HelloJNI_verify(JNIEnv *env, jobject thisObj,jlong product, jbyteArray vk, jbyteArray proof);

#ifdef __cplusplus
}
#endif
using namespace libsnark;

JNIEXPORT void JNICALL Java_HelloJNI_generate(JNIEnv *env, jobject thisObj, jint vectorSize, jobject cbObj) {
    // create a circuit
    r1cs_constrain_cointainer<libff::Fr<default_r1cs_ppzksnark_pp> > container = 
        fill_with_constant(0, (int32_t) vectorSize );

    // geerate key pair
    std::tuple< std::string, std::string  > keyPair =  
            circuit_key_generation<default_r1cs_ppzksnark_pp>(container);

    jclass cls = env->FindClass("jni/KeyPair");
    if (cls == 0 ) {
         printf("class jni/KeyPair not found!\n");
         return;
    }
    jmethodID method = env->GetMethodID(cls, "onKeyPair", "([B[B)V");
    if (method == 0 ) {
        printf("method onKeyPair is not found!\n");
        return;
   
    }
   std::string pk, vk;
   pk = std::get<0>(keyPair), vk = std::get<1>(keyPair);
   jbyteArray pkArray = env->NewByteArray(pk.size());
   env->SetByteArrayRegion (pkArray, 0, pk.size(), reinterpret_cast<const jbyte*>(pk.c_str()));
   jbyteArray vkArray = env->NewByteArray(vk.size());
   env->SetByteArrayRegion(vkArray, 0, vk.size(), reinterpret_cast<const jbyte*>(vk.c_str()));
   env->CallObjectMethod(cbObj, method,pkArray,vkArray);
 }

 JNIEXPORT jbyteArray JNICALL Java_HelloJNI_createProof(JNIEnv *env, jobject thisObj, jbyteArray pk, jlongArray a, jlongArray b) {

    unsigned char * isCopy;
    int32_t pkSize = env->GetArrayLength(pk);
    jbyte* pkBytes = env->GetByteArrayElements(pk, isCopy);
    std::string proofKey(pkBytes,pkBytes + pkSize );
 
    jlong* al = env->GetLongArrayElements(a, isCopy);
    jlong* bl = env->GetLongArrayElements(b, isCopy);
    TupleVecT tupleVector;
    for (size_t i = 0; i < env->GetArrayLength(a); i++ ) {
        tupleVector.push_back(std::make_tuple(al[i], bl[i]));
    }

    r1cs_constrain_cointainer<libff::Fr<default_r1cs_ppzksnark_pp> > container = 
             circuit(tupleVector); 

    std::string proof;
    proof = create_proof<default_r1cs_ppzksnark_pp>(container ,proofKey);

    jbyteArray aProof = env->NewByteArray(proof.size());
    env->SetByteArrayRegion(aProof, 0, proof.size(), reinterpret_cast<const jbyte*>( proof.c_str() ));
    return  aProof;
}

JNIEXPORT jboolean JNICALL Java_HelloJNI_verify(JNIEnv *env, 
        jobject thisObj,jlong product, jbyteArray vk, jbyteArray proof) {

    unsigned char * isCopy;
    // std::string *sVk = new std::string (), *sProof = new std::string ();
    size_t l = env->GetArrayLength(vk);
    jbyte* vkBytes = env->GetByteArrayElements(vk, isCopy);
    std::string sVk = std::string(vkBytes, vkBytes + l );
    size_t pl = env->GetArrayLength(proof);
    jbyte* pBytes = env->GetByteArrayElements(proof, isCopy);
    std::string sProof = std::string(pBytes, pBytes + pl );

    //return  verify_proof<default_r1cs_ppzksnark_pp>(sVk, sProof, product );
    return 0;

}

